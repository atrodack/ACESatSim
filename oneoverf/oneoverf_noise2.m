function cnoise = oneoverf_noise2(nsamps, oversamp, alpha, arg4, arg5)
% ONEOVERF_NOISE2 - generate 1/f^alpha noise in 2 dimensions
%  
% Description: Uses fourier-space convolution to filter a noise image
%              with a 1/f^alpha power spectrum.  The oversampling factor
%              is used to add low-spatial frequency information to the
%              noise, and helps avoid edge effects.  An image of 
%              size (nsamps*oversamp)^2 is generated and filtered, and the 
%              central nsamps*nsamps is extracted and returned.  The output 
%              is normalized by setting the variance of the 
%              (nsamps*oversamp)^2 image to 1.
%
%              A pre-generated noise array can be passed in.  If the noise
%              is generated by this function, then it can be from the
%              normal (default) or uniform distribution.
%
% References: See "Generalized Noll Analysis..." by Jared Males
%
% Syntax:  cnoise = oneoverf_noise(nsamps, oversamp, alpha)
%          cnoise = oneoverf_noise(nsamps, oversamp, alpha, 'dist', 'uniform')
%          cnoise = oneoverf_noise(nsamps, oversamp, alpha, noise)
%
% Inputs:
%    nsamps   - the linear number of samples desired in the output
%    oversamp - the multiplicative oversampling factor, >= 1
%    alpha    - the PSD exponent
%
% Optional Inputs:
%    distribution - the last two arguments can be 'dist', 'uniform' or
%                   'dist', 'normal' to specify the input distribution. 
%                   The default is normal 
%    noise        - use a pre-made noise image instead of generating one
%
% Outputs:
%    cnoise   - the correlated noise image of length nsamp
%
% Other m-files required: none
%
% Subfunctions: none
%
% MAT-files required: none
%
% See also: onveoverf_noise.m
%
% Author: Jared R. Males
% email: jaredmales@gmail.com
% 
% History:
%  - written by JRM on 2015.05.29
%

%------------- BEGIN CODE --------------

%Check on oversamp
if(oversamp < 1) 
   oversamp = 1;
end


%Parse arguments
if nargin == 4 && ~isempty(arg4)
   %if noise vector is supplied as arg4, then we just use it
   noise = arg4;
   [N dim2] = size(noise);  
   
   if N ~= dim2
      error('oneoverf:oneoverf_noise2','noise must be square array');
   end
   
   nsamps = N/oversamp;
else
   %otherwise, figure out which distribution to use
   dist = 0;
   
   if nargin == 5
      if strcmp(arg4,'dist') && strcmp(arg5,'normal')
         dist = 0;
      end
      if strcmp(arg4,'dist') && strcmp(arg5,'uniform')
         dist = 1;
      end
   end
      
   if dist == 1
      noise = rand(nsamps*oversamp, nsamps*oversamp);
   else
      noise = randn(nsamps*oversamp, nsamps*oversamp);
   end
end


[N dim2] = size(noise);

% Calculate the PSD
x = ((0:1:N-1)-N/2)'*ones(1,N)/N;
y = ones(N, 1)*((0:1:N-1)-N/2)/N;

envelope = fftshift(1./(x.^2+y.^2).^(alpha/4));
envelope(1,1) = 0; 

% Now conolve with the PSD
FT = fft2(noise).*envelope;
out = real(fftshift(ifft2(FT)));

%Normalize to variance = 1.0
out = out/std(reshape(out,1,[]));

%Finally, cut out the middle image
st = floor(0.5*N)-floor(0.5*nsamps)+1;
en = floor(0.5*N)-floor(0.5*nsamps)+nsamps;

cnoise = out(st:en,st:en);

end